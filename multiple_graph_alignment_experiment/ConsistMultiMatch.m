% This function is the key algorithm for the paper:
% Junchi Yan et al. Consistency-Driven Alternating Optimization for Multigraph Matching: A Unified Approach
% IEEE Transactions on Image Processing, 2015
% Written by Junchi Yan, 2013-2014

% Algorithm Description see more details and illustration in Fig.1 in the above T-IP pape:
% Given N graphs, use graph r as the reference graph, at each iteration,
% select one graph x rotatingly, compute the matching between graph r and
% graph x P_{rx} by fixing the other N-2 graphs' matchings to graph r
% P_{sr}(s=1,2,...N, s<>r,s<>x)
% the optimization objective are two parts：1) the *direct* affinity between graph r and graph x: \sum_{s}R->X;
% 2) the indirect affinity tansfered by the middle graph X->R->S
function X = ConsistMultiMatch(updtOrder,nodeCnt,graphCnt,algpar,rawMat)
global affinity
bPathSelect = algpar.bPathSelect;
iterMax = algpar.iccvIterMax;% by default only 1 iteration for traversing all graphs for updating is enough 
refGrh = updtOrder(end);
P = cell(graphCnt,graphCnt,2);
F = cell(graphCnt,graphCnt);
J = zeros(graphCnt,2);
bestIdx = 1;% bestIdx index the historical best solution w.r.t affinity score
currIdx = 2;% currIdx index the current solution in iteration
rscope = (refGrh-1)*nodeCnt+1:refGrh*nodeCnt;

% Generate the initial pairwise matchings, 
for x=[1:refGrh-1,refGrh+1:graphCnt]
    if nargin == 5 % if the raw pairwise matchings are given
        xscope = (x-1)*nodeCnt+1:x*nodeCnt;
        P{x,refGrh,bestIdx} = rawMat(xscope,rscope);
    else % otherwise compute the pairwise matching
        P{x,refGrh,bestIdx} = vec2mat(pairMatchSolver(x,refGrh,algpar),nodeCnt,nodeCnt);
    end
    P{x,refGrh,currIdx} = P{x,refGrh,bestIdx};
end

P{refGrh,refGrh} = eye(nodeCnt,nodeCnt);
I = sparse(P{refGrh,refGrh});

for iterk=1:iterMax
    for gk = 1:(graphCnt-1)% graphCnt-1 graphs in the updtOrder quene in descending order by graph-wise consistency 
        uptGrh = updtOrder(gk);
        % the affinity between current graph (uptGrh) and the reference graph (refGrh) 
        totalK = affinity.K{uptGrh,refGrh};
        % the affinity between other fixed graph (fixGrh) and refGrh 
        for fixGrh = 1:graphCnt
            if fixGrh==uptGrh||fixGrh==refGrh, continue;end
            F{fixGrh,refGrh} = kron(P{fixGrh,refGrh,bestIdx},I);% see Eq.6 in the T-IP paper
            totalK = totalK + F{fixGrh,refGrh}'*affinity.K{uptGrh,fixGrh}*F{fixGrh,refGrh};
        end
        totalK = totalK./(graphCnt-1);% normalize the affinity
        % this logic is used for the GAGM implementation, can be ignored here
        if strcmpi(algpar.algMethod,'GAGM'),totalK=sparse(totalK);end
        exeString = ['p=',algpar.algMethod,'(totalK,nodeCnt,nodeCnt,algpar);'];
        eval(exeString);
         if algpar.bDisc
            E12 = ones(affinity.nP{uptGrh},affinity.nP{refGrh});
            p = convert2Discrete(E12,p);
         end
         P{uptGrh,refGrh,currIdx} = vec2mat(p,nodeCnt,nodeCnt);
         % If path selection, select the solution with higher affinity score generated by current P_{ru} and best P_{ru}
         if bPathSelect
             J(uptGrh,currIdx) = mat2vec(P{uptGrh,refGrh,currIdx})'*totalK*mat2vec(P{uptGrh,refGrh,currIdx});%本次迭代的优化函数分数
             J(uptGrh,bestIdx) = mat2vec(P{uptGrh,refGrh,bestIdx})'*totalK*mat2vec(P{uptGrh,refGrh,bestIdx});%本次迭代的优化函数分数
             if J(uptGrh,currIdx)>J(uptGrh,bestIdx)
                P{uptGrh,refGrh,bestIdx} = P{uptGrh,refGrh,currIdx};
            end
         else % Otherwise always update it without comparison
             P{uptGrh,refGrh,bestIdx} = P{uptGrh,refGrh,currIdx};
         end
    end
end
X = zeros(nodeCnt*graphCnt,nodeCnt*graphCnt);
for x = 1:graphCnt
    xscope = (x-1)*nodeCnt+1:x*nodeCnt;
    for y = x+1:graphCnt
        yscope = (y-1)*nodeCnt+1:y*nodeCnt;
        X(xscope,yscope) = P{x,refGrh,bestIdx}*P{y,refGrh,bestIdx}';
    end
end
X = X + X' + eye(nodeCnt*graphCnt,nodeCnt*graphCnt);
